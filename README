NINEL: Algoritmul se bazeaza pe formarea tripletelor (left_tree, current_tree, right_tree), cu 	ajutorul carora putem verifica proprietatea de "copac special". Intrucat numarul datelor 	de intrare poate fi foarte mare, toate operatiile se fac din citire. Primii doi copaci 	(daca exista) se citesc separat, instructiunea repetitiva fiind bazata pe citirea 		celui de-al treilea element al tripletelor. Dupa ce se incrementeaza numarul de copaci 	speciali, se actualizeaza suma inaltimilor si se verifica proprietatea de minim si 		maxim, indicele copacului fiind dat cu ajutorul variabilei de parcurgere a 			instructiunii 	for, tripletul "gliseaza" la stanga in mod asemanator 		algoritmilor de tip "sliding doors", facand loc pentru citirea unei noi valori 	pentru right_tree.

VECTSECV: Algoritmul citeste numarul N si parcurge efectiv pasii descrisi in enuntul 		problemei. Cu ajutorul celor 2 functii se calculeaza valorile n_crescator si 	n_descrescator. Functiile se bazeaza pe construirea unui vector de frecventa care 		numara aparitiie fiecarei cifre in cadrul numarului, urmand sa produca o noua valoare 	prin parcurgerea crescatoare/ descrescatoare a acestuia. Noul element al secventei, 		obtinut prin diferenta celor doua valori calculate este mai intai cautat liniar in 		vectorul "v" care  salveaza valorile gasite. Daca valoarea este regasita in vector, se 	afiseaza numarul etapei de cautare la care ne aflam (care reprezinta, de fapt, numarul 	de valori care nu fac parte din secventa repetitiva), si apoi se afiseaza restul de 	elemente ale tabloului. Daca nu se gaseste numarul in vector, atunci el este adaugat 	la final, iar 	procesul continua pana cand se gaseste un numar care sa regenereze 		secventa, moment in care variabila ok determina incetarea algoritmului.

CODEINVIM: Din dorinta de a utiliza eficient memoria, algoritmul utilizeaza un singur tablou 	unidimensional, care initial memoreaza notele elevului. A doua structura for citeste, 	in variabila "C" ponderile. In aceasta etapa se adauga variabilei "sum" care retine 		punctajul elevului produsul dintre nota corespunzatoare ponderii si ponderea, iar 		elementul tabloului care pana la acest moment retinea nota preia o valoare care 		semnifica punctajul de marire produs de  cuplul nota-pondere. Algoritmul fiind unul de 	tip Greedy, vectorul obtinut este sortat descrescator cu ajutorul functiei, urmand sa 		fie parcurs pentru a mari punctajul, pana cand acesta din urma depaseste valoarea 		"p_min". Prin initializarea valorii cnt, care semnifica raspunsul problemei, cu 0 si 	adaugarea instructiunii if la final, se acopera cazurile particulare in care punctajul 	era de la bun inceput mai mare, sau cazul in care toate maririle insumate nu pot acoperi 		punctajul pmin.     

NOMOGRAM: Pentru rezolvarea problemei, datele despre grupurile de pixeli sunt memorate intr-o 	matrice, prima jumatate retinand informatiile despre linii, iar cea de-a doua 		informatiile despre coloane. Problema este rezolvata prin functia construita, 	creata atat din ratiuni de modularizare a codului, dar si pentru usurinta tratarii 		cazurilor de eroare. Pictograma este parcursa mai intai pe linii, decrementand 		valoarea  corespunzatoare grupului din care pixelul face parte, valoare stocata in 		cadrul matricei. Dupa parcurgerea unei linii din pictograma, linia corespunzatoare din 	matrice este parcursa, conditia de corectitudine a constructiei fiind aceea ca toate 		elementele de  pe linia matrcei trebuie sa aiba valoarea 0. O valoare negativa poate 	semnifica fie grupe  mai mari de pixeli negrii, fie un numar mai mare de grupe decat 	cel admis, iar o valoare pozitiva indica grupuri mai mici de pixeli. La prima astfel 	de anomalie depistata, functia returneaza valoarea 0. Acelasi procedeu se aplica si 		coloanelor, iar la final, daca functia nu a intalnit nicio problema returneaza 		valoarea 1.   
